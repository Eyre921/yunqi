

**ç‰ˆæœ¬ï¼š** V1.0

**åˆ›å»ºæ—¶é—´ï¼š** 2025å¹´1æœˆ

**æŠ€æœ¯æ ˆï¼š** Next.js 14 + TypeScript + Prisma + SQLite

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®èƒŒæ™¯

æ•°å­—åŒ–ä½œå“äº’åŠ¨å±•ç¤ºå¹³å°æ˜¯ä¸ºé…åˆçº¿ä¸‹å¤§å‹æ´»åŠ¨ï¼ˆå¦‚äº‘æ –å¤§ä¼šï¼‰è€Œå¼€å‘çš„ä½œå“å±•ç¤ºç³»ç»Ÿã€‚å¹³å°æ”¯æŒç”¨æˆ·ä¸Šä¼ AIåˆ›ä½œä½œå“ï¼Œæä¾›å®æ—¶å±•ç¤ºå’Œäº’åŠ¨åŠŸèƒ½ï¼Œè¥é€ çƒ­çƒˆçš„æ´»åŠ¨æ°›å›´ã€‚

### 1.2 æŠ€æœ¯æ¶æ„

æœ¬é¡¹ç›®é‡‡ç”¨ç°ä»£åŒ–çš„å…¨æ ˆWebå¼€å‘æŠ€æœ¯æ ˆï¼š

- **å‰ç«¯æ¡†æ¶ï¼š** Next.js 14 (App Router)
- **å¼€å‘è¯­è¨€ï¼š** TypeScript
- **æ ·å¼æ¡†æ¶ï¼š** Tailwind CSS
- **æ•°æ®åº“ORMï¼š** Prisma
- **æ•°æ®åº“ï¼š** SQLite (ç”Ÿäº§ç¯å¢ƒå¯åˆ‡æ¢PostgreSQL)
- **èº«ä»½è®¤è¯ï¼š** NextAuth.js (æ”¯æŒæ¸¸å®¢æ¨¡å¼)
- **æ–‡ä»¶ä¸Šä¼ ï¼š** Cloudinary / æœ¬åœ°å­˜å‚¨
- **éƒ¨ç½²æ–¹å¼ï¼š** PM2 + Standaloneæ¨¡å¼

### 1.3 æ ¸å¿ƒç‰¹æ€§

- **æ¸¸å®¢å‹å¥½ï¼š** æ— éœ€æ³¨å†Œç™»å½•å³å¯æµè§ˆå’Œäº’åŠ¨
- **å®æ—¶å±•ç¤ºï¼š** ä¼ é€å¸¦å¼æ»šåŠ¨å±•ç¤ºï¼Œè¥é€ åŠ¨æ€æ°›å›´
- **ç®€å•ä¸Šä¼ ï¼š** æµç•…çš„ä½œå“ä¸Šä¼ ä½“éªŒ
- **å†…å®¹å®¡æ ¸ï¼š** åå°å®¡æ ¸æœºåˆ¶ç¡®ä¿å†…å®¹å®‰å…¨
- **å“åº”å¼è®¾è®¡ï¼š** é€‚é…PCå¤§å±å’Œç§»åŠ¨è®¾å¤‡

## 2. æ•°æ®åº“è®¾è®¡

### 2.1 æ•°æ®æ¨¡å‹

```prisma:prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ç”¨æˆ·è§’è‰²æšä¸¾
enum Role {
  USER          // æ³¨å†Œç”¨æˆ· - å¯ä»¥ä¸Šä¼ ä½œå“
  ADMIN         // ç®¡ç†å‘˜ - å¯ä»¥å®¡æ ¸ä½œå“
}

// ä½œå“çŠ¶æ€æšä¸¾
enum WorkStatus {
  PENDING       // å¾…å®¡æ ¸
  APPROVED      // å·²é€šè¿‡
  REJECTED      // å·²æ‹’ç»
}

// ç”¨æˆ·æ¨¡å‹ï¼ˆä»…æ³¨å†Œç”¨æˆ·éœ€è¦ï¼‰
model User {
  id            String    @id @default(cuid())
  username      String?   @unique  // ç”¨æˆ·åï¼ˆå¯é€‰ï¼‰
  name          String    // çœŸå®å§“å
  email         String?   @unique  // é‚®ç®±ï¼ˆå¯é€‰ï¼‰
  phone         String?   @unique  // æ‰‹æœºå·ï¼ˆå¯é€‰ï¼‰
  password      String    // å¯†ç 
  role          Role      @default(USER)
  avatar        String?   // å¤´åƒ
  
  // å…³è”ä½œå“
  works         Work[]    @relation("UserWorks")
  moderatedWorks Work[]   @relation("ModeratedWorks")
  
  // NextAuth å¿…éœ€å­—æ®µ
  accounts      Account[]
  sessions      Session[]
  
  // å®¡è®¡å­—æ®µ
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

// ä½œå“æ¨¡å‹
model Work {
  id              String      @id @default(cuid())
  name            String      // ä½œå“åå­— (æœ€å¤š50å­—ç¬¦)
  title           String      // ä½œå“ç®€è¿° (æœ€å¤š300å­—ç¬¦)
  author          String      // ä½œè€…å (æœ€å¤š15å­—ç¬¦)
  prompt          String?     // å®Œæ•´çš„Prompt (æœ€å¤š8000å­—ç¬¦)
  imageUrl        String      // ä½œå“å›¾ç‰‡URL
  status          WorkStatus  @default(PENDING)
  likeCount       Int         @default(0)
  viewCount       Int         @default(0)
  shareCount      Int         @default(0)
  isFeatured      Boolean     @default(false)
  isDeleted       Boolean     @default(false)
  
  // å…³è”ç”¨æˆ·ï¼ˆå¯é€‰ï¼Œæ”¯æŒåŒ¿åä¸Šä¼ ï¼‰
  userId          String?
  user            User?       @relation("UserWorks", fields: [userId], references: [id])
  
  // å®¡æ ¸ç›¸å…³
  moderatorId     String?
  moderator       User?       @relation("ModeratedWorks", fields: [moderatorId], references: [id])
  rejectionReason String?
  
  // æ—¶é—´æˆ³
  createdAt       DateTime    @default(now())
  approvedAt      DateTime?   // å®¡æ ¸é€šè¿‡æ—¶é—´
  updatedAt       DateTime    @updatedAt
}

// NextAuth å¿…éœ€æ¨¡å‹
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ç³»ç»Ÿé…ç½®è¡¨
model SystemConfig {
  id            String   @id @default(cuid())
  key           String   @unique  // é…ç½®é”®
  value         String   // é…ç½®å€¼
  description   String?  // é…ç½®æè¿°
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}
```

## 3. èº«ä»½è®¤è¯ç³»ç»Ÿ

### 3.1 NextAuth.js é…ç½®

```typescript:src/lib/auth.ts
import { AuthOptions } from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import bcrypt from 'bcrypt';
import prisma from '@/lib/prisma';

export const authOptions: AuthOptions = {
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        identifier: { label: 'ç”¨æˆ·å/é‚®ç®±', type: 'text' },
        password: { label: 'å¯†ç ', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.identifier || !credentials?.password) {
          return null;
        }
        
        // æŸ¥æ‰¾ç”¨æˆ·
        const user = await prisma.user.findFirst({
          where: {
            OR: [
              { username: credentials.identifier },
              { email: credentials.identifier },
            ],
          },
        });
        
        if (!user || !user.password) {
          return null;
        }
        
        // éªŒè¯å¯†ç 
        const isValidPassword = await bcrypt.compare(
          credentials.password,
          user.password
        );
        
        if (!isValidPassword) {
          return null;
        }
        
        return {
          id: user.id,
          name: user.name,
          email: user.email,
          role: user.role,
        };
      },
    }),
  ],
  pages: {
    signIn: '/signin',
  },
  session: {
    strategy: 'jwt',
  },
  callbacks: {
    jwt: async ({ token, user }) => {
      if (user) {
        token.role = user.role;
      }
      return token;
    },
    session: async ({ session, token }) => {
      if (token && session.user) {
        session.user.id = token.sub!;
        session.user.role = token.role as string;
      }
      return session;
    },
  },
  secret: process.env.NEXTAUTH_SECRET,
};
```

### 3.2 æƒé™æ§åˆ¶ä¸­é—´ä»¶

```typescript:src/lib/permissions.ts
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { NextRequest } from 'next/server';
import { Role } from '@prisma/client';

// æƒé™æ£€æŸ¥ç»“æœæ¥å£
export interface PermissionResult {
  hasPermission: boolean;
  user?: {
    id: string;
    name: string;
    email?: string;
    role: Role;
  };
  error?: string;
}

/**
 * è·å–ç”¨æˆ·æƒé™ä¿¡æ¯
 */
export async function getUserPermissions(): Promise<PermissionResult> {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.user?.id) {
      return {
        hasPermission: false,
        error: 'ç”¨æˆ·æœªç™»å½•'
      };
    }

    return {
      hasPermission: true,
      user: {
        id: session.user.id,
        name: session.user.name,
        email: session.user.email,
        role: session.user.role as Role,
      }
    };
  } catch (error) {
    console.error('è·å–ç”¨æˆ·æƒé™å¤±è´¥:', error);
    return {
      hasPermission: false,
      error: 'æƒé™æ£€æŸ¥å¤±è´¥'
    };
  }
}

/**
 * æƒé™æ§åˆ¶ä¸­é—´ä»¶
 */
export function withAuth(
  handler: (req: NextRequest) => Promise<Response>,
  options: {
    requiredRole?: Role[];
    allowGuest?: boolean; // æ˜¯å¦å…è®¸æ¸¸å®¢è®¿é—®
  } = {}
) {
  return async function(req: NextRequest): Promise<Response> {
    try {
      const userPermission = await getUserPermissions();
      
      // å…è®¸æ¸¸å®¢è®¿é—®çš„æ¥å£
      if (options.allowGuest && !userPermission.hasPermission) {
        return handler(req);
      }
      
      // æ£€æŸ¥ç™»å½•çŠ¶æ€
      if (!userPermission.hasPermission) {
        return new Response(
          JSON.stringify({ error: userPermission.error || 'éœ€è¦ç™»å½•' }),
          { status: 401, headers: { 'Content-Type': 'application/json' } }
        );
      }
      
      // æ£€æŸ¥è§’è‰²æƒé™
      if (options.requiredRole && userPermission.user) {
        if (!options.requiredRole.includes(userPermission.user.role)) {
          return new Response(
            JSON.stringify({ error: 'æƒé™ä¸è¶³' }),
            { status: 403, headers: { 'Content-Type': 'application/json' } }
          );
        }
      }
      
      return handler(req);
    } catch (error) {
      console.error('æƒé™ä¸­é—´ä»¶é”™è¯¯:', error);
      return new Response(
        JSON.stringify({ error: 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯' }),
        { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
    }
  };
}
```

## 4. API æ¥å£è®¾è®¡

### 4.1 ä½œå“ç®¡ç† API

#### 4.1.1 è·å–ä½œå“åˆ—è¡¨ï¼ˆæ”¯æŒæ¸¸å®¢è®¿é—®ï¼‰

```typescript:src/app/api/works/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withAuth } from '@/lib/permissions';
import prisma from '@/lib/prisma';
import { WorkStatus } from '@prisma/client';

// GET /api/works - è·å–ä½œå“åˆ—è¡¨ï¼ˆå…è®¸æ¸¸å®¢è®¿é—®ï¼‰
export const GET = withAuth(
  async (request: NextRequest) => {
    try {
      const { searchParams } = new URL(request.url);
      const status = searchParams.get('status') || 'APPROVED';
      const sortBy = searchParams.get('sortBy') || 'latest'; // latest, popular
      const page = parseInt(searchParams.get('page') || '1');
      const limit = parseInt(searchParams.get('limit') || '50');
      
      // æ„å»ºæ’åºæ¡ä»¶
      let orderBy: any;
      if (sortBy === 'popular') {
        orderBy = { likeCount: 'desc' };
      } else {
        orderBy = { approvedAt: 'desc' };
      }
      
      const works = await prisma.work.findMany({
        where: {
          status: status as WorkStatus,
          isDeleted: false,
        },
        orderBy,
        skip: (page - 1) * limit,
        take: limit,
        select: {
          id: true,
          name: true,
          title: true,
          author: true,
          prompt: true,
          imageUrl: true,
          likeCount: true,
          viewCount: true,
          createdAt: true,
          approvedAt: true,
        },
      });
      
      return NextResponse.json(works);
    } catch (error) {
      console.error('è·å–ä½œå“åˆ—è¡¨å¤±è´¥:', error);
      return NextResponse.json(
        { error: 'è·å–ä½œå“åˆ—è¡¨å¤±è´¥' },
        { status: 500 }
      );
    }
  },
  { allowGuest: true } // å…è®¸æ¸¸å®¢è®¿é—®
);

// POST /api/works - ä¸Šä¼ ä½œå“ï¼ˆéœ€è¦ç™»å½•ï¼‰
export const POST = withAuth(
  async (request: NextRequest) => {
    try {
      const body = await request.json();
      const { name, title, author, prompt, imageUrl } = body;
      
      // æ•°æ®éªŒè¯
      if (!name || name.length > 50) {
        return NextResponse.json(
          { error: 'ä½œå“åå­—å¿…å¡«ä¸”ä¸è¶…è¿‡50å­—ç¬¦' },
          { status: 400 }
        );
      }
      
      if (!title || title.length > 300) {
        return NextResponse.json(
          { error: 'ä½œå“ç®€è¿°å¿…å¡«ä¸”ä¸è¶…è¿‡300å­—ç¬¦' },
          { status: 400 }
        );
      }
      
      if (!author || author.length > 15) {
        return NextResponse.json(
          { error: 'ä½œè€…åå¿…å¡«ä¸”ä¸è¶…è¿‡15å­—ç¬¦' },
          { status: 400 }
        );
      }
      
      if (prompt && prompt.length > 8000) {
        return NextResponse.json(
          { error: 'Promptä¸è¶…è¿‡8000å­—ç¬¦' },
          { status: 400 }
        );
      }
      
      if (!imageUrl) {
        return NextResponse.json(
          { error: 'ä½œå“å›¾ç‰‡å¿…å¡«' },
          { status: 400 }
        );
      }
      
      // è·å–ç”¨æˆ·ä¿¡æ¯
      const userPermission = await getUserPermissions();
      
      // åˆ›å»ºä½œå“
      const work = await prisma.work.create({
        data: {
          name,
          title,
          author,
          prompt,
          imageUrl,
          status: 'PENDING',
          likeCount: Math.floor(Math.random() * 41) + 10, // åˆå§‹ç‚¹èµæ•°10-50
          userId: userPermission.user?.id,
        },
      });
      
      return NextResponse.json(work, { status: 201 });
    } catch (error) {
      console.error('ä¸Šä¼ ä½œå“å¤±è´¥:', error);
      return NextResponse.json(
        { error: 'ä¸Šä¼ ä½œå“å¤±è´¥' },
        { status: 500 }
      );
    }
  },
  { requiredRole: ['USER', 'ADMIN'] }
);
```

#### 4.1.2 ä½œå“è¯¦æƒ…å’Œäº’åŠ¨

```typescript:src/app/api/works/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withAuth } from '@/lib/permissions';
import prisma from '@/lib/prisma';

// GET /api/works/[id] - è·å–ä½œå“è¯¦æƒ…ï¼ˆæ”¯æŒæ¸¸å®¢è®¿é—®ï¼‰
export const GET = withAuth(
  async (request: NextRequest, { params }: { params: Promise<{ id: string }> }) => {
    try {
      const { id } = await params;
      
      const work = await prisma.work.findUnique({
        where: { id },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              avatar: true,
            },
          },
        },
      });
      
      if (!work || work.isDeleted) {
        return NextResponse.json(
          { error: 'ä½œå“ä¸å­˜åœ¨' },
          { status: 404 }
        );
      }
      
      // åªè¿”å›å·²å®¡æ ¸é€šè¿‡çš„ä½œå“ç»™æ¸¸å®¢
      if (work.status !== 'APPROVED') {
        return NextResponse.json(
          { error: 'ä½œå“ä¸å­˜åœ¨' },
          { status: 404 }
        );
      }
      
      // å¢åŠ æµè§ˆæ¬¡æ•°
      await prisma.work.update({
        where: { id },
        data: {
          viewCount: {
            increment: 1,
          },
        },
      });
      
      return NextResponse.json(work);
    } catch (error) {
      console.error('è·å–ä½œå“è¯¦æƒ…å¤±è´¥:', error);
      return NextResponse.json(
        { error: 'è·å–ä½œå“è¯¦æƒ…å¤±è´¥' },
        { status: 500 }
      );
    }
  },
  { allowGuest: true }
);
```

#### 4.1.3 ç‚¹èµåŠŸèƒ½

```typescript:src/app/api/works/[id]/like/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withAuth } from '@/lib/permissions';
import prisma from '@/lib/prisma';

// POST /api/works/[id]/like - ç‚¹èµä½œå“ï¼ˆæ”¯æŒæ¸¸å®¢è®¿é—®ï¼‰
export const POST = withAuth(
  async (request: NextRequest, { params }: { params: Promise<{ id: string }> }) => {
    try {
      const { id } = await params;
      
      // æ£€æŸ¥ä½œå“æ˜¯å¦å­˜åœ¨ä¸”å·²å®¡æ ¸é€šè¿‡
      const work = await prisma.work.findUnique({
        where: { id },
        select: { id: true, status: true, isDeleted: true },
      });
      
      if (!work || work.isDeleted || work.status !== 'APPROVED') {
        return NextResponse.json(
          { error: 'ä½œå“ä¸å­˜åœ¨' },
          { status: 404 }
        );
      }
      
      // éšæœºå¢åŠ 1-10ç‚¹èµæ•°ï¼ˆæ ¹æ®PRDéœ€æ±‚ï¼‰
      const increment = Math.floor(Math.random() * 10) + 1;
      
      const updatedWork = await prisma.work.update({
        where: { id },
        data: {
          likeCount: {
            increment,
          },
        },
        select: {
          likeCount: true,
        },
      });
      
      return NextResponse.json({ 
        success: true,
        likeCount: updatedWork.likeCount 
      });
    } catch (error) {
      console.error('ç‚¹èµå¤±è´¥:', error);
      return NextResponse.json(
        { error: 'ç‚¹èµå¤±è´¥' },
        { status: 500 }
      );
    }
  },
  { allowGuest: true } // å…è®¸æ¸¸å®¢ç‚¹èµ
);
```

### 4.2 ç®¡ç†å‘˜ API

#### 4.2.1 ä½œå“å®¡æ ¸

```typescript:src/app/api/admin/works/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withAuth, getUserPermissions } from '@/lib/permissions';
import prisma from '@/lib/prisma';

// GET /api/admin/works - è·å–å¾…å®¡æ ¸ä½œå“åˆ—è¡¨
export const GET = withAuth(
  async (request: NextRequest) => {
    try {
      const { searchParams } = new URL(request.url);
      const status = searchParams.get('status') || 'PENDING';
      const page = parseInt(searchParams.get('page') || '1');
      const limit = parseInt(searchParams.get('limit') || '20');
      
      const works = await prisma.work.findMany({
        where: {
          status: status as any,
          isDeleted: false,
        },
        orderBy: {
          createdAt: 'asc', // æŒ‰æäº¤æ—¶é—´æ­£åºæ’åˆ—
        },
        skip: (page - 1) * limit,
        take: limit,
        include: {
          user: {
            select: {
              id: true,
              name: true,
              email: true,
            },
          },
          moderator: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      });
      
      const total = await prisma.work.count({
        where: {
          status: status as any,
          isDeleted: false,
        },
      });
      
      return NextResponse.json({
        works,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit),
        },
      });
    } catch (error) {
      console.error('è·å–ä½œå“åˆ—è¡¨å¤±è´¥:', error);
      return NextResponse.json(
        { error: 'è·å–ä½œå“åˆ—è¡¨å¤±è´¥' },
        { status: 500 }
      );
    }
  },
  { requiredRole: ['ADMIN'] }
);
```

#### 4.2.2 å®¡æ ¸æ“ä½œ

```typescript:src/app/api/admin/works/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withAuth, getUserPermissions } from '@/lib/permissions';
import prisma from '@/lib/prisma';

// PATCH /api/admin/works/[id] - å®¡æ ¸ä½œå“
export const PATCH = withAuth(
  async (request: NextRequest, { params }: { params: Promise<{ id: string }> }) => {
    try {
      const { id } = await params;
      const body = await request.json();
      const { status, rejectionReason } = body;
      
      if (!['APPROVED', 'REJECTED'].includes(status)) {
        return NextResponse.json(
          { error: 'æ— æ•ˆçš„å®¡æ ¸çŠ¶æ€' },
          { status: 400 }
        );
      }
      
      if (status === 'REJECTED' && !rejectionReason) {
        return NextResponse.json(
          { error: 'æ‹’ç»æ—¶å¿…é¡»æä¾›æ‹’ç»åŸå› ' },
          { status: 400 }
        );
      }
      
      const userPermission = await getUserPermissions();
      
      const work = await prisma.work.update({
        where: { id },
        data: {
          status,
          rejectionReason: status === 'REJECTED' ? rejectionReason : null,
          approvedAt: status === 'APPROVED' ? new Date() : null,
          moderatorId: userPermission.user!.id,
        },
      });
      
      return NextResponse.json(work);
    } catch (error) {
      console.error('å®¡æ ¸ä½œå“å¤±è´¥:', error);
      return NextResponse.json(
        { error: 'å®¡æ ¸ä½œå“å¤±è´¥' },
        { status: 500 }
      );
    }
  },
  { requiredRole: ['ADMIN'] }
);
```

### 4.3 ç»Ÿè®¡ API

```typescript:src/app/api/admin/stats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { withAuth } from '@/lib/permissions';
import prisma from '@/lib/prisma';

// GET /api/admin/stats - è·å–ç»Ÿè®¡æ•°æ®
export const GET = withAuth(
  async (request: NextRequest) => {
    try {
      // ä½œå“ç»Ÿè®¡
      const workStats = await prisma.work.groupBy({
        by: ['status'],
        _count: {
          id: true,
        },
        where: {
          isDeleted: false,
        },
      });
      
      // æ€»ç‚¹èµæ•°
      const totalLikes = await prisma.work.aggregate({
        _sum: {
          likeCount: true,
        },
        where: {
          status: 'APPROVED',
          isDeleted: false,
        },
      });
      
      // æ€»æµè§ˆæ•°
      const totalViews = await prisma.work.aggregate({
        _sum: {
          viewCount: true,
        },
        where: {
          status: 'APPROVED',
          isDeleted: false,
        },
      });
      
      // ç”¨æˆ·ç»Ÿè®¡
      const userCount = await prisma.user.count();
      
      // ä»Šæ—¥ç»Ÿè®¡
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const todayStats = await prisma.work.count({
        where: {
          createdAt: {
            gte: today,
          },
          isDeleted: false,
        },
      });
      
      const stats = {
        works: {
          total: workStats.reduce((sum, stat) => sum + stat._count.id, 0),
          pending: workStats.find(s => s.status === 'PENDING')?._count.id || 0,
          approved: workStats.find(s => s.status === 'APPROVED')?._count.id || 0,
          rejected: workStats.find(s => s.status === 'REJECTED')?._count.id || 0,
        },
        interactions: {
          totalLikes: totalLikes._sum.likeCount || 0,
          totalViews: totalViews._sum.viewCount || 0,
        },
        users: {
          total: userCount,
        },
        today: {
          submissions: todayStats,
        },
      };
      
      return NextResponse.json(stats);
    } catch (error) {
      console.error('è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥:', error);
      return NextResponse.json(
        { error: 'è·å–ç»Ÿè®¡æ•°æ®å¤±è´¥' },
        { status: 500 }
      );
    }
  },
  { requiredRole: ['ADMIN'] }
);
```

## 5. å‰ç«¯ç»„ä»¶è®¾è®¡

### 5.1 ä½œå“å±•ç¤ºç»„ä»¶

```typescript:src/components/WorkCard.tsx
import { useState } from 'react';
import Image from 'next/image';
import { Work } from '@prisma/client';

interface WorkCardProps {
  work: Work;
  onClick?: () => void;
}

export default function WorkCard({ work, onClick }: WorkCardProps) {
  const [imageLoaded, setImageLoaded] = useState(false);
  
  return (
    <div 
      className="bg-white rounded-lg shadow-md overflow-hidden cursor-pointer transform hover:scale-105 transition-transform duration-200"
      onClick={onClick}
    >
      <div className="relative aspect-video bg-gray-200">
        <Image
          src={work.imageUrl}
          alt={work.name}
          fill
          className={`object-cover transition-opacity duration-300 ${
            imageLoaded ? 'opacity-100' : 'opacity-0'
          }`}
          onLoad={() => setImageLoaded(true)}
        />
        {!imageLoaded && (
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
          </div>
        )}
      </div>
      
      <div className="p-4">
        <h3 className="font-semibold text-lg mb-2 line-clamp-1">{work.name}</h3>
        <p className="text-gray-600 text-sm mb-2 line-clamp-2">{work.title}</p>
        <div className="flex justify-between items-center text-sm text-gray-500">
          <span>by {work.author}</span>
          <div className="flex items-center space-x-4">
            <span>â¤ï¸ {work.likeCount}</span>
            <span>ğŸ‘ï¸ {work.viewCount}</span>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### 5.2 ä¼ é€å¸¦æ»šåŠ¨ç»„ä»¶

```typescript:src/components/WorkMarquee.tsx
import { useEffect, useState } from 'react';
import WorkCard from './WorkCard';
import { Work } from '@prisma/client';

interface WorkMarqueeProps {
  works: Work[];
  onWorkClick: (work: Work) => void;
}

export default function WorkMarquee({ works, onWorkClick }: WorkMarqueeProps) {
  const [isPaused, setIsPaused] = useState(false);
  
  // å¤åˆ¶ä½œå“æ•°ç»„ä»¥å®ç°æ— ç¼æ»šåŠ¨
  const duplicatedWorks = [...works, ...works];
  
  return (
    <div 
      className="relative overflow-hidden"
      onMouseEnter={() => setIsPaused(true)}
      onMouseLeave={() => setIsPaused(false)}
    >
      <div 
        className={`flex space-x-4 ${
          isPaused ? 'animate-pause' : 'animate-scroll'
        }`}
        style={{
          width: `${duplicatedWorks.length * 320}px`, // æ¯ä¸ªå¡ç‰‡320pxå®½åº¦
        }}
      >
        {duplicatedWorks.map((work, index) => (
          <div key={`${work.id}-${index}`} className="flex-shrink-0 w-80">
            <WorkCard 
              work={work} 
              onClick={() => onWorkClick(work)}
            />
          </div>
        ))}
      </div>
    </div>
  );
}
```

### 5.3 ä½œå“è¯¦æƒ…å¼¹çª—

```typescript:src/components/WorkModal.tsx
import { useState } from 'react';
import Image from 'next/image';
import { Work } from '@prisma/client';

interface WorkModalProps {
  work: Work | null;
  isOpen: boolean;
  onClose: () => void;
}

export default function WorkModal({ work, isOpen, onClose }: WorkModalProps) {
  const [likeCount, setLikeCount] = useState(work?.likeCount || 0);
  const [isLiking, setIsLiking] = useState(false);
  const [copySuccess, setCopySuccess] = useState(false);
  
  if (!isOpen || !work) return null;
  
  const handleLike = async () => {
    if (isLiking) return;
    
    setIsLiking(true);
    try {
      const response = await fetch(`/api/works/${work.id}/like`, {
        method: 'POST',
      });
      
      if (response.ok) {
        const data = await response.json();
        setLikeCount(data.likeCount);
      }
    } catch (error) {
      console.error('ç‚¹èµå¤±è´¥:', error);
    } finally {
      setTimeout(() => setIsLiking(false), 500); // é˜²æ­¢é¢‘ç¹ç‚¹å‡»
    }
  };
  
  const handleCopyPrompt = async () => {
    if (!work.prompt) return;
    
    try {
      await navigator.clipboard.writeText(work.prompt);
      setCopySuccess(true);
      setTimeout(() => setCopySuccess(false), 2000);
    } catch (error) {
      console.error('å¤åˆ¶å¤±è´¥:', error);
    }
  };
  
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto">
        <div className="relative">
          <button
            onClick={onClose}
            className="absolute top-4 right-4 z-10 bg-white rounded-full p-2 shadow-lg hover:bg-gray-100"
          >
            âœ•
          </button>
          
          <div className="aspect-video relative">
            <Image
              src={work.imageUrl}
              alt={work.name}
              fill
              className="object-cover"
            />
          </div>
        </div>
        
        <div className="p-6">
          <h2 className="text-2xl font-bold mb-2">{work.name}</h2>
          <p className="text-gray-600 mb-4">{work.title}</p>
          <p className="text-sm text-gray-500 mb-4">ä½œè€…ï¼š{work.author}</p>
          
          {work.prompt && (
            <div className="mb-6">
              <h3 className="font-semibold mb-2">Prompt:</h3>
              <div className="bg-gray-100 p-4 rounded-lg">
                <p className="text-sm whitespace-pre-wrap">{work.prompt}</p>
              </div>
            </div>
          )}
          
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4 text-sm text-gray-500">
              <span>â¤ï¸ {likeCount}</span>
              <span>ğŸ‘ï¸ {work.viewCount}</span>
            </div>
            
            <div className="flex space-x-3">
              <button
                onClick={handleLike}
                disabled={isLiking}
                className={`px-6 py-2 rounded-lg font-medium transition-colors ${
                  isLiking 
                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                    : 'bg-red-500 text-white hover:bg-red-600'
                }`}
              >
                {isLiking ? 'ç‚¹èµä¸­...' : 'å¤¸å¤¸ä»–'}
              </button>
              
              {work.prompt && (
                <button
                  onClick={handleCopyPrompt}
                  className={`px-6 py-2 rounded-lg font-medium transition-colors ${
                    copySuccess
                      ? 'bg-green-500 text-white'
                      : 'bg-blue-500 text-white hover:bg-blue-600'
                  }`}
                >
                  {copySuccess ? 'å·²å¤åˆ¶' : 'å¤åˆ¶Prompt'}
                </button>
              )}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}
```

## 6. é¡µé¢å®ç°

### 6.1 ä¸»å±•ç¤ºé¡µé¢

```typescript:src/app/page.tsx
'use client';

import { useEffect, useState } from 'react';
import WorkMarquee from '@/components/WorkMarquee';
import WorkModal from '@/components/WorkModal';
import { Work } from '@prisma/client';

export default function HomePage() {
  const [latestWorks, setLatestWorks] = useState<Work[]>([]);
  const [popularWorks, setPopularWorks] = useState<Work[]>([]);
  const [selectedWork, setSelectedWork] = useState<Work | null>(null);
  const [onlineCount, setOnlineCount] = useState(1024);
  const [loading, setLoading] = useState(true);
  
  // æ¨¡æ‹Ÿåœ¨çº¿äººæ•°
  useEffect(() => {
    const interval = setInterval(() => {
      setOnlineCount(prev => prev + Math.floor(Math.random() * 5) + 1);
    }, 10000); // æ¯10ç§’å¢åŠ 1-5äºº
    
    return () => clearInterval(interval);
  }, []);
  
  // è·å–ä½œå“æ•°æ®
  useEffect(() => {
    const fetchWorks = async () => {
      try {
        // è·å–æœ€æ–°ä½œå“
        const latestResponse = await fetch('/api/works?sortBy=latest&limit=10');
        const latestData = await latestResponse.json();
        setLatestWorks(latestData);
        
        // è·å–çƒ­é—¨ä½œå“
        const popularResponse = await fetch('/api/works?sortBy=popular&limit=50');
        const popularData = await popularResponse.json();
        setPopularWorks(popularData);
      } catch (error) {
        console.error('è·å–ä½œå“æ•°æ®å¤±è´¥:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchWorks();
    
    // æ¯åˆ†é’Ÿåˆ·æ–°ä¸€æ¬¡æ•°æ®
    const interval = setInterval(fetchWorks, 60000);
    return () => clearInterval(interval);
  }, []);
  
  // å°†çƒ­é—¨ä½œå“åˆ†ç»„ä¸ºå¤šè¡Œ
  const groupWorksIntoRows = (works: Work[], worksPerRow: number = 10) => {
    const rows = [];
    for (let i = 0; i < works.length; i += worksPerRow) {
      rows.push(works.slice(i, i + worksPerRow));
    }
    return rows;
  };
  
  const popularRows = groupWorksIntoRows(popularWorks);
  
  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      </div>
    );
  }
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-purple-50">
      {/* å¤´éƒ¨æ ‡é¢˜ */}
      <header className="text-center py-8">
        <h1 className="text-4xl font-bold text-gray-800 mb-4">
          æ•°å­—åŒ–ä½œå“äº’åŠ¨å±•ç¤ºå¹³å°
        </h1>
        <p className="text-xl text-red-600 font-semibold">
          {onlineCount}äººæ­£åœ¨äº‘æ –å¤§ä¼šåˆ›ä½œ
        </p>
        
        {/* ä¸Šä¼ æŒ‰é’® */}
        <div className="mt-6">
          <button 
            onClick={() => window.location.href = '/upload'}
            className="bg-blue-600 text-white px-8 py-3 rounded-lg font-semibold hover:bg-blue-700 transition-colors"
          >
            ä¸Šä¼ æˆ‘çš„ä½œå“
          </button>
        </div>
      </header>
      
      {/* ä½œå“å±•ç¤ºåŒºåŸŸ */}
      <main className="space-y-8 pb-8">
        {/* æœ€æ–°ä½œå“è¡Œ */}
        {latestWorks.length > 0 && (
          <div>
            <h2 className="text-2xl font-bold text-center mb-4 text-gray-800">
              ğŸ”¥ æœ€æ–°ä½œå“
            </h2>
            <WorkMarquee 
              works={latestWorks} 
              onWorkClick={setSelectedWork}
            />
          </div>
        )}
        
        {/* çƒ­é—¨ä½œå“è¡Œ */}
        {popularRows.map((rowWorks, index) => (
          <div key={index}>
            {index === 0 && (
              <h2 className="text-2xl font-bold text-center mb-4 text-gray-800">
                â­ çƒ­é—¨ä½œå“
              </h2>
            )}
            <WorkMarquee 
              works={rowWorks} 
              onWorkClick={setSelectedWork}
            />
          </div>
        ))}
      </main>
      
      {/* ä½œå“è¯¦æƒ…å¼¹çª— */}
      <WorkModal
        work={selectedWork}
        isOpen={!!selectedWork}
        onClose={() => setSelectedWork(null)}
      />
    </div>
  );
}
```

### 6.2 ä½œå“ä¸Šä¼ é¡µé¢

```typescript:src/app/upload/page.tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import Image from 'next/image';

export default function UploadPage() {
  const router = useRouter();
  const [formData, setFormData] = useState({
    name: '',
    title: '',
    author: '',
    prompt: '',
  });
  const [imageFile, setImageFile] = useState<File | null>(null);
  const [imagePreview, setImagePreview] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [errors, setErrors] = useState<Record<string, string>>({});
  
  // æ£€æµ‹è®¾å¤‡ç±»å‹
  const isMobile = typeof window !== 'undefined' && window.innerWidth < 768;
  
  if (isMobile) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <div className="text-center">
          <h1 className="text-2xl font-bold mb-4">è¯·ä½¿ç”¨PCæµè§ˆå™¨ä¸Šä¼ ä½œå“</h1>
          <p className="text-gray-600 mb-6">ä¸ºäº†æ›´å¥½çš„ä¸Šä¼ ä½“éªŒï¼Œè¯·åœ¨ç”µè„‘ä¸Šæ‰“å¼€æ­¤é¡µé¢</p>
          <button
            onClick={() => router.push('/')}
            className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700"
          >
            è¿”å›é¦–é¡µ
          </button>
        </div>
      </div>
    );
  }
  
  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    
    // æ¸…é™¤å¯¹åº”å­—æ®µçš„é”™è¯¯
    if (errors[name]) {
      setErrors(prev => ({ ...prev, [name]: '' }));
    }
  };
  
  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;
    
    // éªŒè¯æ–‡ä»¶ç±»å‹
    if (!['image/jpeg', 'image/png'].includes(file.type)) {
      setErrors(prev => ({ ...prev, image: 'ä»…æ”¯æŒJPGå’ŒPNGæ ¼å¼' }));
      return;
    }
    
    // éªŒè¯æ–‡ä»¶å¤§å°
    if (file.size > 5 * 1024 * 1024) {
      setErrors(prev => ({ ...prev, image: 'æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡5MB' }));
      return;
    }
    
    setImageFile(file);
    setImagePreview(URL.createObjectURL(file));
    setErrors(prev => ({ ...prev, image: '' }));
  };
  
  const validateForm = () => {
    const newErrors: Record<string, string> = {};
    
    if (!formData.name || formData.name.length > 50) {
      newErrors.name = 'ä½œå“åå­—å¿…å¡«ä¸”ä¸è¶…è¿‡50å­—ç¬¦';
    }
    
    if (!formData.title || formData.title.length > 300) {
      newErrors.title = 'ä½œå“ç®€è¿°å¿…å¡«ä¸”ä¸è¶…è¿‡300å­—ç¬¦';
    }
    
    if (!formData.author || formData.author.length > 15) {
      newErrors.author = 'ä½œè€…åå¿…å¡«ä¸”ä¸è¶…è¿‡15å­—ç¬¦';
    }
    
    if (formData.prompt && formData.prompt.length > 8000) {
      newErrors.prompt = 'Promptä¸è¶…è¿‡8000å­—ç¬¦';
    }
    
    if (!imageFile) {
      newErrors.image = 'è¯·é€‰æ‹©ä½œå“å›¾ç‰‡';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) return;
    
    setIsSubmitting(true);
    
    try {
      // ä¸Šä¼ å›¾ç‰‡åˆ°äº‘å­˜å‚¨ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼‰
      const imageFormData = new FormData();
      imageFormData.append('file', imageFile!);
      
      const uploadResponse = await fetch('/api/upload', {
        method: 'POST',
        body: imageFormData,
      });
      
      if (!uploadResponse.ok) {
        throw new Error('å›¾ç‰‡ä¸Šä¼ å¤±è´¥');
      }
      
      const { imageUrl } = await uploadResponse.json();
      
      // æäº¤ä½œå“æ•°æ®
      const response = await fetch('/api/works', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ...formData,
          imageUrl,
        }),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'æäº¤å¤±è´¥');
      }
      
      // æˆåŠŸæç¤º
      alert('ä½œå“å·²æäº¤å®¡æ ¸ï¼Œè¯·è€å¿ƒç­‰å¾…ï¼');
      router.push('/');
    } catch (error) {
      console.error('æäº¤å¤±è´¥:', error);
      alert(error instanceof Error ? error.message : 'æäº¤å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <div className="min-h-screen bg-gray-50 py-8">
      <div className="max-w-2xl mx-auto bg-white rounded-lg shadow-md p-8">
        <h1 className="text-3xl font-bold text-center mb-8">ä¸Šä¼ æˆ‘çš„ä½œå“</h1>
        
        <form onSubmit={handleSubmit} className="space-y-6">
          {/* ä½œå“åå­— */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              ä½œå“åå­— <span className="text-red-500">*</span>
            </label>
            <input
              type="text"
              name="name"
              value={formData.name}
              onChange={handleInputChange}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="è¯·è¾“å…¥ä½œå“åå­—ï¼ˆæœ€å¤š50å­—ç¬¦ï¼‰"
              maxLength={50}
            />
            {errors.name && <p className="text-red-500 text-sm mt-1">{errors.name}</p>}
          </div>
          
          {/* ä½œå“ç®€è¿° */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              ä½œå“ç®€è¿° <span className="text-red-500">*</span>
            </label>
            <textarea
              name="title"
              value={formData.title}
              onChange={handleInputChange}
              rows={3}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="è¯·è¾“å…¥ä½œå“ç®€è¿°ï¼ˆæœ€å¤š300å­—ç¬¦ï¼‰"
              maxLength={300}
            />
            {errors.title && <p className="text-red-500 text-sm mt-1">{errors.title}</p>}
          </div>
          
          {/* ä½œè€…å */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              ä½œè€…å <span className="text-red-500">*</span>
            </label>
            <input
              type="text"
              name="author"
              value={formData.author}
              onChange={handleInputChange}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="è¯·è¾“å…¥ä½œè€…åï¼ˆæœ€å¤š15å­—ç¬¦ï¼‰"
              maxLength={15}
            />
            {errors.author && <p className="text-red-500 text-sm mt-1">{errors.author}</p>}
          </div>
          
          {/* Prompt */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Promptï¼ˆå¯é€‰ï¼‰
            </label>
            <textarea
              name="prompt"
              value={formData.prompt}
              onChange={handleInputChange}
              rows={4}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
              placeholder="è¯·è¾“å…¥å®Œæ•´çš„Promptï¼ˆæœ€å¤š8000å­—ç¬¦ï¼‰"
              maxLength={8000}
            />
            {errors.prompt && <p className="text-red-500 text-sm mt-1">{errors.prompt}</p>}
          </div>
          
          {/* ä½œå“å›¾ç‰‡ */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              ä½œå“å›¾ç‰‡ <span className="text-red-500">*</span>
            </label>
            <input
              type="file"
              accept="image/jpeg,image/png"
              onChange={handleImageChange}
              className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            <p className="text-sm text-gray-500 mt-1">
              æ”¯æŒJPGã€PNGæ ¼å¼ï¼Œæ–‡ä»¶å¤§å°ä¸è¶…è¿‡5MB
            </p>
            {errors.image && <p className="text-red-500 text-sm mt-1">{errors.image}</p>}
            
            {/* å›¾ç‰‡é¢„è§ˆ */}
            {imagePreview && (
              <div className="mt-4">
                <p className="text-sm font-medium text-gray-700 mb-2">å›¾ç‰‡é¢„è§ˆï¼š</p>
                <div className="relative aspect-video max-w-md mx-auto border border-gray-300 rounded-md overflow-hidden">
                  <Image
                    src={imagePreview}
                    alt="é¢„è§ˆ"
                    fill
                    className="object-cover"
                  />
                </div>
              </div>
            )}
          </div>
          
          {/* æäº¤æŒ‰é’® */}
          <div className="flex space-x-4">
            <button
              type="button"
              onClick={() => router.push('/')}
              className="flex-1 py-3 px-4 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50 transition-colors"
            >
              å–æ¶ˆ
            </button>
            <button
              type="submit"
              disabled={isSubmitting}
              className={`flex-1 py-3 px-4 rounded-md font-medium transition-colors ${
                isSubmitting
                  ? 'bg-gray-400 text-gray-600 cursor-not-allowed'
                  : 'bg-blue-600 text-white hover:bg-blue-700'
              }`}
            >
              {isSubmitting ? 'å‘å¸ƒä¸­...' : 'å‘å¸ƒ'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}
```

## 7. æ ·å¼é…ç½®

### 7.1 Tailwind CSS åŠ¨ç”»é…ç½®

```javascript:tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      animation: {
        'scroll': 'scroll 20s linear infinite',
        'pause': 'scroll 20s linear infinite paused',
      },
      keyframes: {
        scroll: {
          '0%': { transform: 'translateX(0)' },
          '100%': { transform: 'translateX(-50%)' },
        },
      },
    },
  },
  plugins: [
    require('@tailwindcss/line-clamp'),
  ],
}
```

### 7.2 å…¨å±€æ ·å¼

```css:src/app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

/* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* ä¼ é€å¸¦åŠ¨ç”»æš‚åœ */
.animate-pause {
  animation-play-state: paused !important;
}

/* æ–‡æœ¬æˆªæ–­ */
.line-clamp-1 {
  display: -webkit-box;
  -webkit-line-clamp: 1;
  -webkit-box-orient: vertical;
  overflow: hidden;
}

.line-clamp-2 {
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
  overflow: hidden;
}
```

## 8. ç¯å¢ƒé…ç½®

### 8.1 ç¯å¢ƒå˜é‡

```bash:.env.local
# æ•°æ®åº“
DATABASE_URL="file:./dev.db"

# NextAuth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-nextauth-secret-key"

# æ–‡ä»¶ä¸Šä¼ ï¼ˆCloudinaryç¤ºä¾‹ï¼‰
CLOUDINARY_CLOUD_NAME="your-cloud-name"
CLOUDINARY_API_KEY="your-api-key"
CLOUDINARY_API_SECRET="your-api-secret"

# ç®¡ç†å‘˜é»˜è®¤å¯†ç 
ADMIN_DEFAULT_PASSWORD="admin123456"
```

### 8.2 Next.js é…ç½®

```typescript:next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  output: 'standalone',
  images: {
    unoptimized: true,
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'res.cloudinary.com',
      },
      {
        protocol: 'https',
        hostname: '**',
      },
    ],
  },
  // æ”¯æŒå¤§æ–‡ä»¶ä¸Šä¼ 
  experimental: {
    serverComponentsExternalPackages: ['sharp'],
  },
};

export default nextConfig;
```

### 8.3 åŒ…ä¾èµ–
